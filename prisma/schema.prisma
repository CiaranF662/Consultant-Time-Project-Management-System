// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String    @id @default(cuid())
  name            String?
  email           String?   @unique
  emailVerified   DateTime?
  image           String?
  password        String?
  role            UserRole  @default(CONSULTANT)
  status          UserStatus @default(APPROVED)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  accounts        Account[]
  sessions        Session[]

  // CHANGE: This is now a relation through the join table
  projects        ConsultantsOnProjects[]

  assignedTasks   Task[]
  sprintHours     ConsultantSprintHours[]
  changeRequests  HourChangeRequest[]   @relation("ChangeRequestRequester")
  approvedChanges HourChangeRequest[]   @relation("ChangeRequestApprover")
}


model Project {
  id            String    @id @default(cuid())
  title         String
  description   String?
  startDate     DateTime
  endDate       DateTime?
  
  // CHANGE: The direct consultant link is replaced by the join table
  consultants   ConsultantsOnProjects[]

  sprints       Sprint[]
  phases        Phase[]
  tasks         Task[]
  sprintHours   ConsultantSprintHours[]

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Phase {
  id          String   @id @default(cuid())
  name        String
  description String?
  startDate   DateTime
  endDate     DateTime
  
  projectId   String
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  // CHANGE: A phase now contains a list of sprints.
  sprints     Sprint[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Sprint {
  id            String    @id @default(cuid())
  // CHANGE: 'name' is replaced with a number for easier sequence tracking within a project.
  sprintNumber  Int
  startDate     DateTime
  endDate       DateTime
  expectedHours Int       @default(80)

  // CHANGE: Sprint is now a child of Project. This is the most critical change.
  projectId     String
  project       Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  // CHANGE: A sprint can optionally belong to a phase.
  phaseId       String?
  phase         Phase?    @relation(fields: [phaseId], references: [id])

  tasks          Task[]
  sprintHours    ConsultantSprintHours[]
  changeRequests HourChangeRequest[]

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // CHANGE: The unique constraint is now on the combination of project and sprint number,
  // not on the dates. This allows different projects to have sprints with overlapping dates.
  @@unique([projectId, sprintNumber])
}

// The Task model does not need changes. Its existing links to Sprint and Project
// work perfectly with the new structure.
model Task {
  id          String     @id @default(cuid())
  title       String
  description String?
  status      TaskStatus @default(TODO)
  
  sprintId    String
  sprint      Sprint     @relation(fields: [sprintId], references: [id])
  
  projectId   String
  project     Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  assigneeId  String?
  assignee    User?      @relation(fields: [assigneeId], references: [id])
  
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
}

model ConsultantsOnProjects {
  user       User     @relation(fields: [userId], references: [id])
  userId     String
  project    Project  @relation(fields: [projectId], references: [id])
  projectId  String
  assignedAt DateTime @default(now())

  @@id([userId, projectId])
}


// No changes needed for ConsultantSprintHours or HourChangeRequest.
// Their relationships remain valid.
model ConsultantSprintHours {
  id           String @id @default(cuid())
  hours        Float
  weekNumber   Int
  consultantId String
  sprintId     String
  projectId    String

  consultant User    @relation(fields: [consultantId], references: [id])
  sprint     Sprint  @relation(fields: [sprintId], references: [id])
  project    Project @relation(fields: [projectId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([consultantId, sprintId, projectId, weekNumber])
}

model HourChangeRequest {
  id             String       @id @default(cuid())
  originalHours  Float
  requestedHours Float
  reason         String
  status         ChangeStatus @default(PENDING)
  weekNumber     Int
  consultantId   String
  sprintId       String
  projectId      String

  requester      User         @relation("ChangeRequestRequester", fields: [consultantId], references: [id])
  sprint         Sprint       @relation(fields: [sprintId], references: [id])
  approverId     String?
  approver       User?        @relation("ChangeRequestApprover", fields: [approverId], references: [id])

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
}

// --- Authentication and other models remain unchanged ---

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum UserRole {
  GROWTH_TEAM
  CONSULTANT
}

enum ChangeStatus {
  PENDING
  APPROVED
  REJECTED
}

enum UserStatus {
  PENDING
  APPROVED
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
}